// Code generated by protoc-gen-go. DO NOT EDIT.
// source: grpc/testing/benchmark_service.proto

package grpc_testing

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() {
	proto.RegisterFile("grpc/testing/benchmark_service.proto", fileDescriptor_d29e0fce4682bc17)
}

var fileDescriptor_d29e0fce4682bc17 = []byte{
	// 205 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0xd1, 0xbd, 0x4a, 0xc4, 0x40,
	0x10, 0x07, 0x70, 0x82, 0x20, 0xb8, 0x28, 0xe8, 0xda, 0x25, 0x96, 0x16, 0x56, 0x1b, 0xd1, 0x37,
	0x48, 0x20, 0xa5, 0x45, 0x82, 0x58, 0xca, 0x26, 0x0c, 0x9b, 0xc5, 0xfd, 0x72, 0x66, 0x15, 0xf2,
	0x42, 0x3e, 0xa7, 0x24, 0xb9, 0x0b, 0x77, 0xdc, 0x75, 0x5b, 0xcf, 0x7f, 0x7e, 0xcc, 0x07, 0x7b,
	0x54, 0x18, 0x86, 0x32, 0x02, 0x45, 0xed, 0x54, 0xd9, 0x83, 0x1b, 0x46, 0x2b, 0xf1, 0xeb, 0x93,
	0x00, 0x7f, 0xf5, 0x00, 0x22, 0xa0, 0x8f, 0x9e, 0x5f, 0xcf, 0x29, 0xb1, 0x4b, 0xe5, 0xc5, 0x51,
	0x8f, 0x05, 0x22, 0xa9, 0x80, 0xd6, 0xe8, 0xcb, 0xdf, 0x05, 0xbb, 0xad, 0xf6, 0x4c, 0xb7, 0x2a,
	0xbc, 0x61, 0x57, 0xef, 0x4e, 0xe2, 0x54, 0x4b, 0x63, 0x78, 0x21, 0x0e, 0x35, 0xd1, 0x69, 0x1b,
	0x0c, 0xb4, 0xf0, 0xfd, 0x03, 0x14, 0xf3, 0x87, 0xf3, 0x45, 0x0a, 0xde, 0x11, 0xf0, 0x37, 0x76,
	0xd3, 0x45, 0x04, 0x69, 0xb5, 0x53, 0x89, 0xd6, 0x53, 0xf6, 0x9c, 0xf1, 0x96, 0xdd, 0x6f, 0x5e,
	0x83, 0xde, 0xd6, 0x46, 0x83, 0x8b, 0x49, 0xea, 0x89, 0x39, 0xdf, 0x00, 0x30, 0xc1, 0x5c, 0xe6,
	0xbc, 0xdb, 0xcc, 0xca, 0xc7, 0xf1, 0x43, 0x4e, 0x94, 0xb8, 0x7b, 0x7f, 0xb9, 0xfc, 0xeb, 0xf5,
	0x3f, 0x00, 0x00, 0xff, 0xff, 0x41, 0x99, 0x45, 0x6d, 0x02, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// BenchmarkServiceClient is the client API for BenchmarkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BenchmarkServiceClient interface {
	// One request followed by one response.
	// The server returns the client payload as-is.
	UnaryCall(ctx context.Context, in *SimpleRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
	// Repeated sequence of one request followed by one response.
	// Should be called streaming ping-pong
	// The server returns the client payload as-is on each response
	StreamingCall(ctx context.Context, opts ...grpc.CallOption) (BenchmarkService_StreamingCallClient, error)
	// Single-sided unbounded streaming from client to server
	// The server returns the client payload as-is once the client does WritesDone
	StreamingFromClient(ctx context.Context, opts ...grpc.CallOption) (BenchmarkService_StreamingFromClientClient, error)
	// Single-sided unbounded streaming from server to client
	// The server repeatedly returns the client payload as-is
	StreamingFromServer(ctx context.Context, in *SimpleRequest, opts ...grpc.CallOption) (BenchmarkService_StreamingFromServerClient, error)
	// Two-sided unbounded streaming between server to client
	// Both sides send the content of their own choice to the other
	StreamingBothWays(ctx context.Context, opts ...grpc.CallOption) (BenchmarkService_StreamingBothWaysClient, error)
}

type benchmarkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBenchmarkServiceClient(cc grpc.ClientConnInterface) BenchmarkServiceClient {
	return &benchmarkServiceClient{cc}
}

func (c *benchmarkServiceClient) UnaryCall(ctx context.Context, in *SimpleRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, "/grpc.testing.BenchmarkService/UnaryCall", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *benchmarkServiceClient) StreamingCall(ctx context.Context, opts ...grpc.CallOption) (BenchmarkService_StreamingCallClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BenchmarkService_serviceDesc.Streams[0], "/grpc.testing.BenchmarkService/StreamingCall", opts...)
	if err != nil {
		return nil, err
	}
	x := &benchmarkServiceStreamingCallClient{stream}
	return x, nil
}

type BenchmarkService_StreamingCallClient interface {
	Send(*SimpleRequest) error
	Recv() (*SimpleResponse, error)
	grpc.ClientStream
}

type benchmarkServiceStreamingCallClient struct {
	grpc.ClientStream
}

func (x *benchmarkServiceStreamingCallClient) Send(m *SimpleRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *benchmarkServiceStreamingCallClient) Recv() (*SimpleResponse, error) {
	m := new(SimpleResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *benchmarkServiceClient) StreamingFromClient(ctx context.Context, opts ...grpc.CallOption) (BenchmarkService_StreamingFromClientClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BenchmarkService_serviceDesc.Streams[1], "/grpc.testing.BenchmarkService/StreamingFromClient", opts...)
	if err != nil {
		return nil, err
	}
	x := &benchmarkServiceStreamingFromClientClient{stream}
	return x, nil
}

type BenchmarkService_StreamingFromClientClient interface {
	Send(*SimpleRequest) error
	CloseAndRecv() (*SimpleResponse, error)
	grpc.ClientStream
}

type benchmarkServiceStreamingFromClientClient struct {
	grpc.ClientStream
}

func (x *benchmarkServiceStreamingFromClientClient) Send(m *SimpleRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *benchmarkServiceStreamingFromClientClient) CloseAndRecv() (*SimpleResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SimpleResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *benchmarkServiceClient) StreamingFromServer(ctx context.Context, in *SimpleRequest, opts ...grpc.CallOption) (BenchmarkService_StreamingFromServerClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BenchmarkService_serviceDesc.Streams[2], "/grpc.testing.BenchmarkService/StreamingFromServer", opts...)
	if err != nil {
		return nil, err
	}
	x := &benchmarkServiceStreamingFromServerClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BenchmarkService_StreamingFromServerClient interface {
	Recv() (*SimpleResponse, error)
	grpc.ClientStream
}

type benchmarkServiceStreamingFromServerClient struct {
	grpc.ClientStream
}

func (x *benchmarkServiceStreamingFromServerClient) Recv() (*SimpleResponse, error) {
	m := new(SimpleResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *benchmarkServiceClient) StreamingBothWays(ctx context.Context, opts ...grpc.CallOption) (BenchmarkService_StreamingBothWaysClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BenchmarkService_serviceDesc.Streams[3], "/grpc.testing.BenchmarkService/StreamingBothWays", opts...)
	if err != nil {
		return nil, err
	}
	x := &benchmarkServiceStreamingBothWaysClient{stream}
	return x, nil
}

type BenchmarkService_StreamingBothWaysClient interface {
	Send(*SimpleRequest) error
	Recv() (*SimpleResponse, error)
	grpc.ClientStream
}

type benchmarkServiceStreamingBothWaysClient struct {
	grpc.ClientStream
}

func (x *benchmarkServiceStreamingBothWaysClient) Send(m *SimpleRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *benchmarkServiceStreamingBothWaysClient) Recv() (*SimpleResponse, error) {
	m := new(SimpleResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BenchmarkServiceServer is the server API for BenchmarkService service.
type BenchmarkServiceServer interface {
	// One request followed by one response.
	// The server returns the client payload as-is.
	UnaryCall(context.Context, *SimpleRequest) (*SimpleResponse, error)
	// Repeated sequence of one request followed by one response.
	// Should be called streaming ping-pong
	// The server returns the client payload as-is on each response
	StreamingCall(BenchmarkService_StreamingCallServer) error
	// Single-sided unbounded streaming from client to server
	// The server returns the client payload as-is once the client does WritesDone
	StreamingFromClient(BenchmarkService_StreamingFromClientServer) error
	// Single-sided unbounded streaming from server to client
	// The server repeatedly returns the client payload as-is
	StreamingFromServer(*SimpleRequest, BenchmarkService_StreamingFromServerServer) error
	// Two-sided unbounded streaming between server to client
	// Both sides send the content of their own choice to the other
	StreamingBothWays(BenchmarkService_StreamingBothWaysServer) error
}

// UnimplementedBenchmarkServiceServer can be embedded to have forward compatible implementations.
type UnimplementedBenchmarkServiceServer struct {
}

func (*UnimplementedBenchmarkServiceServer) UnaryCall(ctx context.Context, req *SimpleRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnaryCall not implemented")
}
func (*UnimplementedBenchmarkServiceServer) StreamingCall(srv BenchmarkService_StreamingCallServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamingCall not implemented")
}
func (*UnimplementedBenchmarkServiceServer) StreamingFromClient(srv BenchmarkService_StreamingFromClientServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamingFromClient not implemented")
}
func (*UnimplementedBenchmarkServiceServer) StreamingFromServer(req *SimpleRequest, srv BenchmarkService_StreamingFromServerServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamingFromServer not implemented")
}
func (*UnimplementedBenchmarkServiceServer) StreamingBothWays(srv BenchmarkService_StreamingBothWaysServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamingBothWays not implemented")
}

func RegisterBenchmarkServiceServer(s *grpc.Server, srv BenchmarkServiceServer) {
	s.RegisterService(&_BenchmarkService_serviceDesc, srv)
}

func _BenchmarkService_UnaryCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimpleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BenchmarkServiceServer).UnaryCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.testing.BenchmarkService/UnaryCall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BenchmarkServiceServer).UnaryCall(ctx, req.(*SimpleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BenchmarkService_StreamingCall_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BenchmarkServiceServer).StreamingCall(&benchmarkServiceStreamingCallServer{stream})
}

type BenchmarkService_StreamingCallServer interface {
	Send(*SimpleResponse) error
	Recv() (*SimpleRequest, error)
	grpc.ServerStream
}

type benchmarkServiceStreamingCallServer struct {
	grpc.ServerStream
}

func (x *benchmarkServiceStreamingCallServer) Send(m *SimpleResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *benchmarkServiceStreamingCallServer) Recv() (*SimpleRequest, error) {
	m := new(SimpleRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BenchmarkService_StreamingFromClient_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BenchmarkServiceServer).StreamingFromClient(&benchmarkServiceStreamingFromClientServer{stream})
}

type BenchmarkService_StreamingFromClientServer interface {
	SendAndClose(*SimpleResponse) error
	Recv() (*SimpleRequest, error)
	grpc.ServerStream
}

type benchmarkServiceStreamingFromClientServer struct {
	grpc.ServerStream
}

func (x *benchmarkServiceStreamingFromClientServer) SendAndClose(m *SimpleResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *benchmarkServiceStreamingFromClientServer) Recv() (*SimpleRequest, error) {
	m := new(SimpleRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BenchmarkService_StreamingFromServer_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SimpleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BenchmarkServiceServer).StreamingFromServer(m, &benchmarkServiceStreamingFromServerServer{stream})
}

type BenchmarkService_StreamingFromServerServer interface {
	Send(*SimpleResponse) error
	grpc.ServerStream
}

type benchmarkServiceStreamingFromServerServer struct {
	grpc.ServerStream
}

func (x *benchmarkServiceStreamingFromServerServer) Send(m *SimpleResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _BenchmarkService_StreamingBothWays_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BenchmarkServiceServer).StreamingBothWays(&benchmarkServiceStreamingBothWaysServer{stream})
}

type BenchmarkService_StreamingBothWaysServer interface {
	Send(*SimpleResponse) error
	Recv() (*SimpleRequest, error)
	grpc.ServerStream
}

type benchmarkServiceStreamingBothWaysServer struct {
	grpc.ServerStream
}

func (x *benchmarkServiceStreamingBothWaysServer) Send(m *SimpleResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *benchmarkServiceStreamingBothWaysServer) Recv() (*SimpleRequest, error) {
	m := new(SimpleRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _BenchmarkService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.testing.BenchmarkService",
	HandlerType: (*BenchmarkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UnaryCall",
			Handler:    _BenchmarkService_UnaryCall_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamingCall",
			Handler:       _BenchmarkService_StreamingCall_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamingFromClient",
			Handler:       _BenchmarkService_StreamingFromClient_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamingFromServer",
			Handler:       _BenchmarkService_StreamingFromServer_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamingBothWays",
			Handler:       _BenchmarkService_StreamingBothWays_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "grpc/testing/benchmark_service.proto",
}
