/*
Copyright 2021 gRPC authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package runner contains code for a test runner that can run a list of
// load tests, wait for them to complete, and report on the results.
package runner

import (
	"fmt"
	"log"
	"strings"
	"time"
	"unicode"

	grpcv1 "github.com/grpc/test-infra/api/v1"
	"github.com/grpc/test-infra/tools/runner/junit"
)

// TestSuitesReporter manages reports for all groups of tests.
type TestSuitesReporter struct {
	logPrefixFmt string
	startTime    time.Time
	tss          *junit.TestSuites
}

// NewTestSuitesReporter creates a reporter for a set of test suites.
func NewTestSuitesReporter(logPrefixFmt string, suites *junit.TestSuites) *TestSuitesReporter {
	return &TestSuitesReporter{
		logPrefixFmt: logPrefixFmt,
		tss:          suites,
	}
}

// SetStartTime records the start time of the test.
func (r *TestSuitesReporter) SetStartTime(startTime time.Time) {
	r.startTime = startTime
}

// SetEndTime records the end time of the test.
func (r *TestSuitesReporter) SetEndTime(endTime time.Time) {
	if r.tss != nil {
		r.tss.TimeInSeconds = endTime.Sub(r.startTime).Seconds()
	}
}

// NewTestSuiteReporter creates a new suite reporter instance.
func (r *TestSuitesReporter) NewTestSuiteReporter(qName string) *TestSuiteReporter {
	var ts *junit.TestSuite
	if r.tss != nil {
		ts = &junit.TestSuite{
			ID:   Dashify(qName),
			Name: qName,
		}
		r.tss.Suites = append(r.tss.Suites, ts)
	}

	tsReporter := &TestSuiteReporter{
		qName:        qName,
		logPrefixFmt: r.logPrefixFmt,
		ts:           ts,
	}

	return tsReporter
}

// func (r *TestSuitesReporter) XMLReport() ([]byte, error) {
// 	tssJUnitObject := r.junitObject()
// 	bytes, err := xml.MarshalIndent(tssJUnitObject, "", "  ")
// 	if err != nil {
// 		return nil, errors.Wrapf(err, "failed to generate an XML report")
// 	}
// 	return bytes, nil
// }

// TestSuiteReporter manages reports for tests that share a runner queue.
type TestSuiteReporter struct {
	qName         string
	logPrefixFmt  string
	testCaseCount int
	startTime     time.Time
	ts            *junit.TestSuite
}

// SetStartTime records the start time of the test.
func (sr *TestSuiteReporter) SetStartTime(startTime time.Time) {
	sr.startTime = startTime
}

// SetEndTime records the end time of the test.
func (sr *TestSuiteReporter) SetEndTime(endTime time.Time) {
	if sr.ts != nil {
		sr.ts.TimeInSeconds = endTime.Sub(sr.startTime).Seconds()
	}
}

// Queue returns the name of the queue containing tests for this test suite.
func (sr *TestSuiteReporter) Queue() string {
	return sr.qName
}

// NewTestCaseReporter creates a new reporter instance.
func (sr *TestSuiteReporter) NewTestCaseReporter(config *grpcv1.LoadTest) *TestCaseReporter {
	logPrefix := fmt.Sprintf(sr.logPrefixFmt, sr.qName, sr.testCaseCount)

	var tc *junit.TestCase
	if sr.ts != nil {
		tc = &junit.TestCase{
			ID:   config.Name,
			Name: config.Annotations["scenario"],
		}
		sr.ts.Cases = append(sr.ts.Cases, tc)
	}

	tcReporter := &TestCaseReporter{
		logPrintf: func(format string, v ...interface{}) {
			log.Printf(logPrefix+format, v...)
		},
		index: sr.testCaseCount,
		tc:    tc,
	}

	sr.testCaseCount++
	return tcReporter
}

// TestCaseReporter collects events for logging and reporting during a test.
type TestCaseReporter struct {
	startTime time.Time
	duration  time.Duration
	logPrintf func(format string, v ...interface{})
	index     int
	tc        *junit.TestCase
}

// Index returns the index of the test case in the test suite (and queue).
func (cr *TestCaseReporter) Index() int {
	return cr.index
}

// Info records an informational message generated by the test. This information
// is included in the logs, but it is not included in the JUnit report.
func (cr *TestCaseReporter) Info(format string, v ...interface{}) {
	cr.logPrintf(format, v...)
}

// Warning records a warning message generated during the test. The error that
// caused the message to be generated is also included. It accepts a message
// which is a short string literal that identifies the problem, as well as, a
// format string and arguments for a more verbose description.
func (cr *TestCaseReporter) Warning(message, textFmt string, v ...interface{}) {
	cr.logPrintf(textFmt, v...)
	if cr.tc != nil {
		cr.tc.Failures = append(cr.tc.Failures, &junit.Failure{
			Type:    junit.Warning,
			Message: message,
			Text:    fmt.Sprintf(textFmt, v...),
		})
	}
}

// Error records an error message generated during the test. The error that
// caused the message to be generated is also included. It accepts a message
// which is a short string literal that identifies the problem, as well as, a
// format string and arguments for a more verbose description.
func (cr *TestCaseReporter) Error(message, textFmt string, v ...interface{}) {
	cr.logPrintf(textFmt, v...)
	if cr.tc != nil {
		cr.tc.Failures = append(cr.tc.Failures, &junit.Failure{
			Type:    junit.Error,
			Message: message,
			Text:    fmt.Sprintf(textFmt, v...),
		})
	}
}

// SetStartTime records the start time of the test.
func (cr *TestCaseReporter) SetStartTime(startTime time.Time) {
	cr.startTime = startTime
}

// SetEndTime records the end time of the test.
func (cr *TestCaseReporter) SetEndTime(endTime time.Time) {
	cr.duration = endTime.Sub(cr.startTime)
	if cr.tc != nil {
		cr.tc.TimeInSeconds = cr.duration.Seconds()
	}
}

// TestDuration returns the duration of the test.
func (cr *TestCaseReporter) TestDuration() time.Duration {
	return cr.duration
}

// Dashify returns the input string where all whitespace and underscore
// characters have been replaced by dashes and, aside from dashes, only
// alphanumeric characters remain.
func Dashify(str string) string {
	// TODO: Move this into another shared package.
	b := strings.Builder{}
	for _, rune := range str {
		if string(rune) == "_" || unicode.IsSpace(rune) {
			b.WriteString("-")
		} else if string(rune) == "-" || unicode.IsLetter(rune) || unicode.IsNumber(rune) {
			b.WriteRune(rune)
		}
	}
	return b.String()
}
